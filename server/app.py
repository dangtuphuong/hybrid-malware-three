from flask import Flask, request, jsonify, send_file
from flask_cors import CORS
import os
from dotenv import load_dotenv
import mysql.connector
from mysql.connector import Error
from model import train_model, analyse_data, predict, PCA_data
import pandas as pd
import zipfile
import io
import pickle

# Load environment variables from .env file
load_dotenv()

app = Flask(__name__)
CORS(app)   

# MySQL connection configuration
db_config = {
    'host': os.getenv('DB_HOST'),
    'database': os.getenv('DB_NAME'),
    'user': os.getenv('DB_USER'),
    'password': os.getenv('DB_PASS'),
}

# Function to connect to MySQL

def connect_to_db():
    try:
        connection = mysql.connector.connect(**db_config)
        if connection.is_connected():
            print("Successfully connect to the DB")
            return connection
    except Error as e:
        print(f"Error connecting to MySQL: {e}")
        return None

@app.route('/api/authenticate', methods=['POST','GET'])
def authenticate_user():
    data = request.json
    email = data.get('email')
    password = data.get('password')

    if not email or not password:
        return jsonify({"error": "Missing email or password"}), 400

    connection = connect_to_db()
    if not connection:
        return jsonify({"error": "Unable to connect to the database"}), 500

    try:
        cursor = connection.cursor(dictionary=True)
        cursor.execute(
            "SELECT * FROM users WHERE email = %s AND password = %s", (email, password))
        user = cursor.fetchone()

        if user:
            return jsonify({"message": "Authentication successful", "user": user}), 200
        else:
            return jsonify({"error": "Invalid email or password"}), 401
    except Error as e:
        return jsonify({"error": str(e)}), 500
    finally:
        if connection.is_connected():
            cursor.close()
            connection.close()


@app.route('/api/register', methods=['POST'])
def register_user():
    data = request.json
    name = data.get('name')
    email = data.get('email')
    password = data.get('password')
    role = data.get('role')

    if not name or not email or not password or not role:
        return jsonify({"error": "Missing name, email, password, or role"}), 400

    if role not in [0, 1]:
        return jsonify({"error": "Role must be either 0 or 1"}), 400

    connection = connect_to_db()
    if not connection:
        return jsonify({"error": "Unable to connect to the database"}), 500

    try:
        cursor = connection.cursor()

        # Insert user into the database
        sql = "INSERT INTO users (name, email, password, role) VALUES (%s, %s, %s, %s)"
        val = (name, email, password, role)
        cursor.execute(sql, val)

        connection.commit()

        # Fetch the newly registered user
        cursor.execute(
            "SELECT id, name, email, role FROM users WHERE email = %s", (email,))
        user_data = cursor.fetchone()
        if user_data:
            user = {
                "id": user_data[0],
                "name": user_data[1],
                "email": user_data[2],
                "role": user_data[3]
            }
            return jsonify({"message": "User registered successfully", "user": user}), 200
        else:
            return jsonify({"error": "User registration failed"}), 500

    except Error as e:
        return jsonify({"error": str(e)}), 500

    finally:
        if connection.is_connected():
            cursor.close()
            connection.close()

@app.route('/api/cnn/train', methods=['POST', 'GET'])
def train_data():
    if 'file' not in request.files or 'label' not in request.form:
        return 'Missing file or label', 400
    
    file = request.files['file']
    label = request.form['label']
    user = request.form['user']

    data = pd.read_csv(file)

    connection = connect_to_db()

    model_id, distribution, epoches, description = train_model(data, label, connection, user)

    data = {
        "distribution": distribution,
        "description": description,
        "modelID": model_id,
        "epoches": epoches
    }

    return jsonify(data), 200

@app.route('/api/cnn/predict', methods=['POST', 'GET'])
def predict_data():
    if 'file' not in request.files or 'label' not in request.form:
        return 'Missing file or label', 400
    
    file = request.files['file']
    label = request.form['label']
    modelID = request.form['id']

    connection = connect_to_db()
    cursor = connection.cursor()

    models_q = 'SELECT modelBlob FROM models WHERE models.id = %s'
    cursor.execute(models_q, (modelID,))
    modelBlob = cursor.fetchone()

    print(label, modelID)

    binary = modelBlob[0]

    model_data = pickle.loads(binary)
    model = model_data['model']
    encoder = model_data['label_encoder']

    data = pd.read_csv(file)

    labels = predict(data, label, model, encoder)

    return jsonify(labels), 200

@app.route('/api/models', methods=['GET', 'POST'])
def get_models():
    connection = connect_to_db()
    cursor = connection.cursor()

    models_q = 'SELECT * FROM models JOIN users ON models.createdBy = users.id'
    cursor.execute(models_q)
    models = cursor.fetchall()

    fModels = []
    for i in range(len(models)):
        fModels.append({
            'id': models[i][0],
            'modelName': models[i][1],
            'date': models[i][3],
            'user': { 
                'name': models[i][10],
                'role': models[i][13],
                'email': models[i][11]
            }
        })

    return jsonify(fModels), 200

@app.route('/api/model/data', methods=['GET', 'POST'])
def get_model():
    data = request.json
    modelID = data.get('id')

    connection = connect_to_db()
    cursor = connection.cursor()

    models_q = 'SELECT * FROM models JOIN model_history ON models.id = model_history.modelID WHERE models.id = %s'
    cursor.execute(models_q, (modelID,))
    models = cursor.fetchall()

    if (len(models) > 0):
        epoches = []
        for i in range(len(models)):
            epoches.append({
                "epoch": models[i][10],
                "loss": models[i][11],
                "accuracy": models[i][12],
                "val_loss": models[i][13],
                "val_accuracy": models[i][14]
            })
        distribution = models[0][6]
        description = models[0][7]

        data = {
            "distribution": distribution,
            "description": description,
            "epoches": epoches
        }

        cursor.close()
        connection.close()

        return jsonify(data), 200
    else:
        cursor.close()
        connection.close()
        return "No such as model", 501


@app.route('/api/model/image', methods=['GET', 'POST'])
def get_model_image():
    data = request.json
    modelID = data.get('id')

    connection = connect_to_db()
    cursor = connection.cursor()

    models_q = 'SELECT corImg, topCorImg FROM models WHERE models.id = %s'
    cursor.execute(models_q, (modelID,))
    model = cursor.fetchone()

    corImg = model[0]
    topCorImg = model[1]

    memory_file = io.BytesIO()

    with zipfile.ZipFile(memory_file, 'w') as zf:
        zf.writestr(f'chart_cor.png', corImg)
        zf.writestr(f'chart_top_cor.png', topCorImg)

    memory_file.seek(0)

    cursor.close()
    connection.close()

    return send_file(memory_file, download_name='charts.zip', as_attachment=True)

@app.route('/api/analyse', methods=['POST', 'GET'])
def analyse():
    if 'file' not in request.files or 'label' not in request.form:
        return 'Missing file or label', 400
    
    file = request.files['file']
    label = request.form['label']
    model = request.form['model']

    data = pd.read_csv(file)

    connection = connect_to_db()
    corImg = analyse_data(data, label, model, connection)

    connection = connect_to_db()
    topCorImg = PCA_data(data, label, model, connection)

    memory_file = io.BytesIO()

    with zipfile.ZipFile(memory_file, 'w') as zf:
        zf.writestr(f'chart_cor.png', corImg.getvalue())
        zf.writestr(f'chart_top_cor.png', topCorImg.getvalue())
    
    memory_file.seek(0)

    return send_file(memory_file, download_name='charts.zip', as_attachment=True)


if __name__ == '__main__':
    app.run()
